{
	"template": {
		"prefix": "tmp",
		"body": [
			"#include <bits/stdc++.h>",
            "#include <atcoder/all>",
            "#include <debug.hpp>",
            "using namespace std;",
			"using namespace atcoder;",
			"",
			"template <typename T> vector<T> make_vector(int n) { return vector<T>(n); }",
			"template <typename T, typename... Tail> auto make_vector(int n, Tail... tail) {",
			"    return vector<decltype(make_vector<T>(tail...))>(n, make_vector<T>(tail...));",
			"}",
			"template <class T> bool chmax(T& l, const T& r) { return l < r ? l = r, true : false; }",
			"template <class T> bool chmin(T& l, const T& r) { return l > r ? l = r, true : false; }",
			"",
            "using ll = long long;",
            "const int INF = numeric_limits<int>::max() / 2;",
            "const ll LINF = numeric_limits<ll>::max() / 2;",
            "using mint = modint1000000007;",
			"",
            "int main() {",
            "    $0",
			"}"
		]
	},

	"include": {
		"prefix": "include",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"using namespace std;",
			"using namespace atcoder;",
			"",
			"using ll = long long;",
			"",
			""
		]
	},

	"main": {
		"prefix": "main",
		"body": [
			"int main() {",
			"    $0",
			"}"
		]
	},

	"for": {
		"prefix": "for",
		"body": [
			"for (int ${1:i} = 0; ${1:i} < ${2:n}; ++${1:i}) $0"
		]
	},

	"while": {
		"prefix": "while",
		"body": [
			"while (${1: }) $0"
		]
	},

	"if": {
		"prefix": "if",
		"body": [
			"if (${1: }) $0"
		]
	},

	"else": {
		"prefix": "else",
		"body": [
			"else $0"
		]
	},

	"cin": {
		"prefix": "cin",
		"body": [
			"cin >> $0;"
		]
	},

	"cout": {
		"prefix": "cout",
		"body": [
			"cout << $0 << endl;"
		]
	},

	"return": {
		"prefix": "return",
		"body": [
			"return ${1:0};"
		]
	},

	"long long": {
		"prefix": "long",
		"body": [
			"long long"
		]
	},

	"continue": {
		"prefix": "continue",
		"body": [
			"continue;"
		]
	},

	"break": {
		"prefix": "break",
		"body": [
			"break;"
		]
	},

	"vector": {
		"prefix": "vector",
		"body": [
			"vector<${1: }>"
		]
	},

	"string": {
		"prefix": "string",
		"body": [
			"string"
		]
	},

	"stack": {
		"prefix": "stack",
		"body": [
			"stack<${1: }>"
		]
	},

	"queue": {
		"prefix": "queue",
		"body": [
			"queue<${1: }>"
		]
	},

	"deque": {
		"prefix": "deque",
		"body": [
			"deque<${1: }>"
		]
	},

	"priority_queue": {
		"prefix": "priority_queue",
		"body": [
			"priority_queue<${1: }>"
		]
	},

	"set": {
		"prefix": "set",
		"body": [
			"set<${1: }>"
		]
	},

	"map": {
		"prefix": "map",
		"body": [
			"map<${1: }>"
		]
	},

	"push_back": {
		"prefix": "push_back",
		"body": [
			"push_back($0);"
		]
	},

	"pair": {
		"prefix": "pair",
		"body": [
			"pair<${1: }>"
		]
	},

	"typedef": {
		"prefix": "typedef",
		"body": [
			"typedef $0"
		]
	},

	"namespace": {
		"prefix": "namespace",
		"body": [
			"namespace $0"
		]
	},

	"bitset": {
		"prefix": "bitset",
		"body": [
			"bitset<${1: }>"
		]
	},

	"next_permutation": {
		"prefix": "next_permutation",
		"body": [
			"next_permutation(${1: }.begin(), ${1: }.end())"
		]
	},

	"numeric_limits": {
		"prefix": "numeric_limits",
		"body": [
			"numeric_limits<${1: }>::max() / 2;"
		]
	},

	"binary_search": {
		"prefix": "binary_search",
		"body": [
			"binary_search(${1: }.begin(), ${1: }.end(), ${2:})"
		]
	},

	"lower_bound": {
		"prefix": "lower_bound",
		"body": [
			"lower_bound(${1: }.begin(), ${1: }.end(), ${2:})"
		]
	},

	"upper_bound": {
		"prefix": "upper_bound",
		"body": [
			"upper_bound(${1: }.begin(), ${1: }.end(), ${2:})"
		]
	},

	"max_element": {
		"prefix": "max_element",
		"body": [
			"max_element(${1: }.begin(), ${1: }.end())"
		]
	},

	"min_element": {
		"prefix": "min_element",
		"body": [
			"min_element(${1: }.begin(), ${1: }.end())"
		]
	},

	"sort": {
		"prefix": "sort",
		"body": [
			"sort(${1: }.begin(), ${1: }.end());"
		]
	},

	"reverse": {
		"prefix": "reverse",
		"body": [
			"reverse(${1: }.begin(), ${1: }.end());"
		]
	},

	"resize": {
		"prefix": "resize",
		"body": [
			"resize(${1: });"
		]
	},

	"all": {
		"prefix": "all",
		"body": [
			"${1: }.begin(), ${1: }.end()"
		]
	},

	"unique": {
		"prefix": "unique",
		"body": [
			"unique(${1: }.begin(), ${1: }.end())"
		]
	},

	"accumulate": {
		"prefix": "accumulate",
		"body": [
			"accumulate(${1: }.begin(), ${1: }.end(), ${2:0LL})"
		]
	},

	"remove": {
		"prefix": "remove",
		"body": [
			"remove(${1: }.begin(), ${1: }.end(), ${2:});"
		]
	},

	"const": {
		"prefix": "const",
		"body": [
			"const "
		]
	},

	"to_string": {
		"prefix": "to_string",
		"body": [
			"to_string(${1: })"
		]
	},

	"yes": {
		"prefix": "yes",
		"body": [
			"cout << \"Yes\" << endl;"
		]
	},

	"no": {
		"prefix": "no",
		"body": [
			"cout << \"No\" << endl;"
		]
	},

	"setprecision": {
		"prefix": "setprecision",
		"body": [
			"fixed << setprecision(${1:10})"
		]
	},

	"greater": {
		"prefix": "greater",
		"body": [
			"greater<${1: }>"
		]
	},

	"segtree": {
		"prefix": "segtree",
		"body": [
			"segtree<S, op, e> seg(${1:N});"
		]
	},

	"lazy_segtree": {
		"prefix": "lazy_segtree",
		"body": [
			"lazy_segtree<S, op, e, F, mapping, composition, id> seg(${1:N});"
		]
	},

	"fenwick": {
		"prefix": "fenwick",
		"body": [
			"fenwick<${1: }> fw(${2:N});"
		]
	},

	"floor_sum": {
		"prefix": "floor_sum",
		"body": [
			"floor_sum($1)"
		]
	}

}